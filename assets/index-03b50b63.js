var d=Object.defineProperty;var _=(i,e,t)=>e in i?d(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var n=(i,e,t)=>(_(i,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const c of o)if(c.type==="childList")for(const h of c.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&r(h)}).observe(document,{childList:!0,subtree:!0});function t(o){const c={};return o.integrity&&(c.integrity=o.integrity),o.referrerPolicy&&(c.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?c.credentials="include":o.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function r(o){if(o.ep)return;o.ep=!0;const c=t(o);fetch(o.href,c)}})();const f={size:600,scale:15,snakeColor:"green",foodColor:"red"};class u{constructor(e={}){n(this,"_config");n(this,"_canvas");n(this,"_context");n(this,"_keyHandlers",{});this.setConfig(e),this.createCanvas(),this.initEventListeners()}draw(e,t){this.clearContext(),this._context.fillStyle=this._config.snakeColor,e.forEach(r=>{this._context.fillRect(r.x*this._config.scale,r.y*this._config.scale,this._config.scale-1,this._config.scale-1)}),this._context.fillStyle=this._config.foodColor,this._context.fillRect(t.x*this._config.scale,t.y*this._config.scale,this._config.scale-1,this._config.scale-1)}addKeyEventHandler(e,t){this._keyHandlers[e]=t}setConfig(e={}){this._config=Object.assign(e,f)}createCanvas(){const e=document.querySelector("#app");this._canvas=document.createElement("canvas"),this._canvas.setAttribute("width",this._config.size.toString()),this._canvas.setAttribute("height",this._config.size.toString()),e.appendChild(this._canvas),this._context=this._canvas.getContext("2d")}clearContext(){this._context.clearRect(0,0,this._config.size,this._config.size)}initEventListeners(){document.addEventListener("keydown",e=>{this._keyHandlers[e.key]&&this._keyHandlers[e.key]()})}}var a=(i=>(i.LEFT_ARROW="ArrowLeft",i.RIGHT_ARROW="ArrowRight",i.UP_ARROW="ArrowUp",i.DOWN_ARROW="ArrowDown",i))(a||{}),s=(i=>(i.LEFT="LEFT",i.RIGHT="RIGHT",i.UP="UP",i.DOWN="DOWN",i))(s||{}),l=(i=>(i.STATE_UPDATE="STATE_UPDATE",i))(l||{});class g{constructor(){n(this,"observers");this.observers=[]}broadcast(e,t){this.observers.filter(r=>r.event===e).forEach(r=>r.callback(t))}subscribe(e,t){this.observers.push({event:e,callback:t})}}const y={fieldSize:40,renderInterval:100};class p{constructor(e={}){n(this,"_config");n(this,"_food");n(this,"_cells");n(this,"_direction");n(this,"_observer");this.setConfig(e),this.initCells(),this.generateNewFood(),this.initDirection(),this._observer=new g}setDirection(e){this.isDirectionChangePossible(e)&&(this._direction=e)}startGame(){const e=setInterval(()=>{const{x:t,y:r}=this._cells.at(-1);if(this._direction===s.RIGHT&&this._cells.push({x:t+1,y:r}),this._direction===s.LEFT&&this._cells.push({x:t-1,y:r}),this._direction===s.UP&&this._cells.push({x:t,y:r-1}),this._direction===s.DOWN&&this._cells.push({x:t,y:r+1}),this.hasHeadIntersectionWithWall()||this.hasHeadIntersectionWithBody()){clearInterval(e),this.restartGame();return}this.hasHeadIntersectionWithFood()?this.generateNewFood():this._cells.shift(),this._observer.broadcast(l.STATE_UPDATE,{snake:this._cells,food:this._food})},this._config.renderInterval)}subscribe(e,t){this._observer.subscribe(e,t)}setConfig(e={}){this._config=Object.assign(e,y)}initCells(){this._cells=[{x:this._config.fieldSize/2-1,y:this._config.fieldSize/2},{x:this._config.fieldSize/2,y:this._config.fieldSize/2},{x:this._config.fieldSize/2+1,y:this._config.fieldSize/2}]}initDirection(){this._direction=s.RIGHT}isDirectionChangePossible(e){return{[s.LEFT]:s.RIGHT,[s.UP]:s.DOWN,[s.RIGHT]:s.LEFT,[s.DOWN]:s.UP}[e]!==this._direction}hasHeadIntersectionWithFood(){const{x:e,y:t}=this._cells.at(-1);return e===this._food.x&&t===this._food.y}hasHeadIntersectionWithWall(){const{x:e,y:t}=this._cells.at(-1);return e>this._config.fieldSize||t>this._config.fieldSize||t<0||e<0}hasHeadIntersectionWithBody(){const{x:e,y:t}=this._cells.at(-1);return this._cells.slice(0,this._cells.length-1).some(({x:o,y:c})=>e===o&&t===c)}generateNewFood(){this._food={x:Math.floor(Math.random()*this._config.fieldSize),y:Math.floor(Math.random()*this._config.fieldSize)}}restartGame(){this.initCells(),this.initDirection(),this.generateNewFood(),this.startGame()}}class v{constructor(e,t){n(this,"_model");n(this,"_view");this._model=e,this._view=t,this.initViewKeyEventHandlers(),this.subscribeToModelEvents()}startGame(){this._model.startGame()}initViewKeyEventHandlers(){this._view.addKeyEventHandler(a.LEFT_ARROW,()=>this._model.setDirection(s.LEFT)),this._view.addKeyEventHandler(a.RIGHT_ARROW,()=>this._model.setDirection(s.RIGHT)),this._view.addKeyEventHandler(a.UP_ARROW,()=>this._model.setDirection(s.UP)),this._view.addKeyEventHandler(a.DOWN_ARROW,()=>this._model.setDirection(s.DOWN))}subscribeToModelEvents(){this._model.subscribe(l.STATE_UPDATE,({snake:e,food:t})=>{this._view.draw(e,t)})}}class m{constructor(e=new v(new p,new u)){n(this,"_presenter");this._presenter=e}startGame(){this._presenter.startGame()}}const b=new m;b.startGame();
